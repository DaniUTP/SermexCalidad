pipeline {
    agent any

    environment {
        PROJECT_DIR   = "${WORKSPACE}\\project"
        SOURCE_REPO   = "https://github.com/ZoneMinder/zoneminder.git"
        TARGET_REPO   = "https://github.com/DaniUTP/SermexCalidad.git"
        SONAR_SCANNER = "C:\\Users\\Daniel\\Documents\\Actividades avanzadas calidad de software\\expo calidad repo daniel\\sonar-scanner-cli-7.3.0.5189-windows-x64\\sonar-scanner-7.3.0.5189-windows-x64\\bin\\sonar-scanner.bat"
    }

    stages {
        stage('Preparar Workspace') {
            steps {
                bat """
                if exist "${PROJECT_DIR}" rd /s /q "${PROJECT_DIR}"
                mkdir "${PROJECT_DIR}"
                """
            }
        }

        stage('Clonar Repositorio Zoneminder') {
            steps {
                bat """
                cd /d "${PROJECT_DIR}"
                git clone ${SOURCE_REPO} src
                """
            }
        }

        stage('Analizar con SonarQube') {
            steps {
                withCredentials([string(credentialsId: 'sonarqube', variable: 'TOKEN')]) {
                    bat """
                    cd /d "${PROJECT_DIR}\\src"
                    "${SONAR_SCANNER}" ^
                        -Dsonar.projectKey=SERMEX ^
                        -Dsonar.sources=. ^
                        -Dsonar.host.url=http://localhost:9000 ^
                        -Dsonar.token=%TOKEN%
                    """
                }
            }
        }

       stage('Obtener y Validar Métricas SonarQube') {
    steps {
        script {
            withCredentials([string(credentialsId: 'sonarqube', variable: 'TOKEN')]) {

                // 1) Leer report-task.txt para obtener ceTaskUrl
                def reportFile = "${PROJECT_DIR}\\src\\.scannerwork\\report-task.txt"
                if (!fileExists(reportFile)) {
                    error "No se encontró report-task.txt. El análisis no llegó a SonarQube o falló el scanner."
                }
                def contenido = readFile(reportFile)
                def ceTaskUrl = contenido.split("\n").find { it.startsWith("ceTaskUrl=") }?.replace("ceTaskUrl=", "")?.trim()
                if (!ceTaskUrl) error "ceTaskUrl no encontrado en report-task.txt. No se puede esperar al CE."

                echo "CE Task URL: ${ceTaskUrl}"

                // 2) Esperar a que la tarea CE termine y obtener analysisId
                def parseJson = { text -> new groovy.json.JsonSlurper().parseText(text) }
                def analysisId = null

                // Espera con un máximo de intentos (evita colgar forever)
                def maxAttempts = 60      // si chequeas cada 5s, son ~5 minutos; ajusta si necesitas más tiempo
                def attempt = 0
                def ceStatus = null

                while (attempt < maxAttempts) {
                    attempt++
                    echo "Poll CE status (intent ${attempt}/${maxAttempts})..."
                    // Llamada al ceTaskUrl y guardar en archivo temporal
                    bat """curl -s -u %TOKEN%: "${ceTaskUrl}" -o "${PROJECT_DIR}\\task.json" """

                    def raw = readFile("${PROJECT_DIR}\\task.json")
                    def json = parseJson(raw)
                    ceStatus = json.task?.status
                    echo "CE status = ${ceStatus}"

                    if (ceStatus == "SUCCESS") {
                        analysisId = json.task.analysisId
                        break
                    } else if (ceStatus == "FAILED") {
                        error "La CE task falló en SonarQube (status=FAILED). Revisa Sonar logs."
                    }

                    // Espera antes del siguiente intento (5s)
                    sleep time: 5, unit: 'SECONDS'
                }

                if (!analysisId) {
                    error "Timeout esperando que SonarQube procese el análisis (CE)."
                }

                echo "AnalysisId encontrado: ${analysisId}"

                // 3) Pedir métricas — si vienen vacías, reintentar un par de veces
                def metricsUrlBase = "http://localhost:9000/api/measures/component"
                def metricKeys = "bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density,security_hotspots"
                def measuresJsonFile = "${PROJECT_DIR}\\metrics.json"
                def measuresObj = null
                def tries = 0
                def maxMeasureTries = 10

                while (tries < maxMeasureTries) {
                    tries++
                    echo "Solicitando métricas (intento ${tries}/${maxMeasureTries})..."
                    
                    bat """curl -s -u %TOKEN%: "${metricsUrlBase}?component=SERMEX&metricKeys=${metricKeys}" -o "${measuresJsonFile}" """

                    def rawMetrics = readFile(measuresJsonFile)
                    measuresObj = parseJson(rawMetrics)

                    if (measuresObj?.component?.measures && measuresObj.component.measures.size() > 0) {
                        echo "Métricas recibidas correctamente."
                        break
                    }

                    echo "Métricas vacías, esperando 3s antes de reintentar..."
                    sleep time: 3, unit: 'SECONDS'
                }

                if (!measuresObj?.component?.measures || measuresObj.component.measures.size() == 0) {
                    echo "DEBUG: contenido metrics.json:\n" + readFile(measuresJsonFile)
                    error "No se obtuvieron métricas válidas después de varios intentos. measures=[]"
                }

                def metrics = [:]
                measuresObj.component.measures.each { m ->
                    def raw = m.value
                    if (raw == null || raw.toString().trim() == "") raw = "0"
                    def num
                    try {
                        num = new java.math.BigDecimal(raw.toString())
                    } catch (Exception ex) {
                        num = new java.math.BigDecimal("0")
                    }
                    metrics[m.metric] = num
                    echo "${m.metric}: ${num}"
                }

                def errores = []
                if (metrics['bugs'].compareTo(new java.math.BigDecimal("0")) > 0) {
                    errores << "Bugs detectados: ${metrics['bugs']}"
                }
                if (metrics['vulnerabilities'].compareTo(new java.math.BigDecimal("0")) > 0) {
                    errores << "Vulnerabilidades encontradas: ${metrics['vulnerabilities']}"
                }
                if (metrics['code_smells'].compareTo(new java.math.BigDecimal("20")) > 0) {
                    errores << "Demasiados code smells: ${metrics['code_smells']}"
                }
                if (metrics['coverage'].compareTo(new java.math.BigDecimal("80")) < 0) {
                    errores << "Cobertura baja: ${metrics['coverage']}%"
                }
                if (metrics['duplicated_lines_density'].compareTo(new java.math.BigDecimal("5")) > 0) {
                    errores << "Código duplicado mayor a 5%: ${metrics['duplicated_lines_density']}%"
                }
                if (metrics['security_hotspots'].compareTo(new java.math.BigDecimal("0")) > 0) {
                    errores << "Security Hotspots encontrados: ${metrics['security_hotspots']}"
                }

                if (errores.size() > 0) {
                    echo "HAY ERRORES EN EL CÓDIGO"
                    errores.each { e -> echo e }
                    error "El código no cumple los requisitos mínimos. Se cancela el push."
                }

                echo "EL CODIGO CUMPLE LOS REQUISITOS MINIMOS"
            }
        }
    }
}

        stage('Clonar Repositorio SermexCalidad') {
            steps {
                bat """
                cd /d "${PROJECT_DIR}"
                git clone ${TARGET_REPO} target
                """
            }
        }

        stage('Copiar Código Aprobado') {
            steps {
                bat """
                xcopy "${PROJECT_DIR}\\src\\*" "${PROJECT_DIR}\\target\\" /E /H /C /Y
                """
            }
        }

        stage('Commit y Push') {
            steps {
                withCredentials([string(credentialsId: 'github_token', variable: 'GIT_TOKEN')]) {
                    bat """
                    cd /d "${PROJECT_DIR}\\target"

                    git config --global user.email "aldanagerardo24@gmail.com"
                    git config --global user.name "Daniel Aldana"

                    git remote set-url origin https://DaniUTP:%GIT_TOKEN%@github.com/DaniUTP/SermexCalidad.git

                    rem Excluir .scannerwork de Git
                    echo ".scannerwork" > .gitignore

                    git add .
                    git commit -m "Push automático desde Jenkins (Quality Gate OK)" || echo "Sin cambios para commit"

                    git push origin main --force
                    """
                }
            }
        }
    }

    post {
        success {
            echo "Pipeline completado correctamente. Código aprobado y push realizado."
        }
        failure {
            echo "Pipeline falló. Quality Gate no aprobado o error en ejecución."
        }
    }
}
